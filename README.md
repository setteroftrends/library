

---

# RESTful API для управления библиотечным каталогом

Этот проект представляет собой RESTful API для управления библиотечным каталогом, разработанный в рамках тестового задания для стажёра Python-разработчика. API позволяет управлять книгами, читателями, а также процессом выдачи и возврата книг. Аутентификация реализована с использованием JWT (access и refresh токены).

## Требования для запуска

* Python 3.8+
* SQLite (используется для разработки, с возможностью перехода на PostgreSQL путём замены `DATABASE_URL`)
* Установленные зависимости: `fastapi`, `sqlalchemy`, `python-jose[cryptography]`, `passlib[bcrypt]`, `alembic`, `pytest`

### Установка

1. Клонируйте репозиторий:

   ```bash
   git clone https://github.com/setteroftrends/library.git
   cd library
   ```

2. Установите зависимости:

   ```bash
   pip install -r requirements.txt
   ```

3. Настройте базу данных:

   * Для SQLite: база данных создаётся автоматически при первом запуске.
   * Для PostgreSQL:

     * Создайте базу данных.
     * Обновите `DATABASE_URL` в файле `.env` (например, `postgresql://user:password@localhost:5432/library`).
     * В файле `alembic.ini` измените строку:

       ```ini
       sqlalchemy.url = sqlite:///database.db
       ```

       на:

       ```ini
       sqlalchemy.url = postgresql://user:password@localhost:5432/library
       ```

4. Примените миграции:

   ```bash
   alembic upgrade head
   ```

5. Запустите приложение:

   ```bash
   uvicorn main:app --reload
   ```

### Регистрация первого пользователя

Для создания первого библиотекаря отправьте POST-запрос на `/auth/register`:

```json
{
  "email": "librarian@example.com",
  "password": "your_secure_password"
}
```

Для получения токенов используйте `/auth/login`:

```json
{
  "email": "librarian@example.com",
  "password": "your_secure_password"
}
```

В ответе вы получите `access_token` (действует 15 минут) и `refresh_token` (действует 30 дней). Для обновления access-токена используйте `/auth/refresh` с refresh-токеном.

### Запуск тестов

Для запуска юнит-тестов используйте:

```bash
pytest -v
```

* Тесты используют SQLite в памяти для скорости и изоляции.
* Убедитесь, что зависимости из `requirements.txt` установлены перед запуском тестов.

## Структура базы данных

* **users**: Хранит данные библиотекарей (id, email, hashed\_password).
* **refresh\_tokens**: Хранит refresh-токены (id, user\_id, token, expires\_at).
* **books**: Хранит книги (id, title, author, publication\_year, isbn, copies\_available, description).
* **readers**: Хранит читателей (id, name, email).
* **borrowed\_books**: Хранит записи о выдаче книг (id, book\_id, reader\_id, date\_borrowed, date\_returned).

> SQLite используется для упрощения разработки и тестирования. Переход на PostgreSQL поддерживается заменой `DATABASE_URL` и обновлением `sqlalchemy.url` в `alembic.ini`.

## Реализация бизнес-логики

Бизнес-логика реализована в `ReaderCRUD`, который управляет операциями с читателями и выдачей/возвратом книг:

### 1. Выдача книги (`POST /borrow`)

* Проверка существования читателя и книги.
* Проверка наличия доступных экземпляров (`copies_available > 0`).
* Проверка лимита: не более 3 книг на одного читателя.
* В случае успеха:

  * создаётся запись в `borrowed_books` с `date_borrowed`,
  * `copies_available` уменьшается на 1.
* Все операции в транзакции.

### 2. Возврат книги (`POST /return`)

* Проверка существования читателя и книги.
* Проверка наличия активной записи в `borrowed_books` (`date_returned IS NULL`).
* В случае успеха:

  * устанавливается `date_returned`,
  * `copies_available` увеличивается на 1.
* Все операции в транзакции.

### 3. Ограничения

* Используются транзакции SQLAlchemy для предотвращения race conditions.
* Ошибки сопровождаются информативными сообщениями (HTTP 400/404).

## Аутентификация

* **JWT-токены**:

  * `access_token`: HS256, срок 15 минут.
  * `refresh_token`: срок 30 дней, хранится в базе.
* **Библиотеки**:

  * `python-jose` — для JWT.
  * `passlib[bcrypt]` — для хеширования паролей.
* **Доступ к эндпоинтам**:

  * `/auth/register` и `/auth/login` — открытые.
  * Остальные защищены `access_token`.
* **Почему `/books` защищён**:

  * Защита каталога снижает риски несанкционированного доступа.

## Выбор технологий

* **SQLite** — простота настройки.
* **SQLAlchemy ORM** — абстракция от SQL, поддержка разных СУБД.
* **FastAPI + Pydantic** — быстрый API и валидация данных.
* **Alembic** — миграции БД.

## Тесты

Покрывают:

* Аутентификацию.
* CRUD для книг и читателей.
* Логику выдачи/возврата книг.
* Ограничение в 3 книги.
* Попытки вернуть чужую/невыданную книгу.

## Сложности и решения

1. **Refresh-токены**: Инвалидация реализована через таблицу с `expires_at`.
2. **Race conditions при выдаче книг**: Использование транзакций.
3. **Тестирование логики**: Использование SQLite в памяти и фикстур `pytest`.

## Дополнительная фича

**Просроченные книги**:

* Эндпоинт `/notifications/overdue` показывает книги, не возвращённые более 14 дней.
* Фильтрация по `borrowed_books.date_borrowed`.
* Защищён JWT.
* В будущем можно добавить email-уведомления через `smtplib`.

## Замечания

* Код оформлен по PEP8.
* Для продакшена рекомендуется:

  * добавить кэширование (например, Redis),
  * внедрить rate limiting.

---

Примечание: Из-за переинициализации репозитория были утеряны некоторые коммиты. :(

